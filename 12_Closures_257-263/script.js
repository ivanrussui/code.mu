// 12_Closures_257-263
// Замыкания


// 257 Доступ к внешним переменным / Доступ к внешним переменным функций в JavaScript
//
// Давайте рассмотрим следующий код:
//
//     let num = 1; // задаем значение переменной
//
// function func() {
//     console.log(num); // выводим его в консоль
// }
//
// func(); // вызываем функцию
// Как я уже упоминал ранее, значение переменной не обязательно должно быть перед определением функции, главное,
// чтобы оно стояло перед ее вызовом:
//
//     function func() {
//         console.log(num);
//     }
//
// let num = 1;
// func();
// На самом деле это не совсем так. Наша функция даже до своего вызова знает значение переменной num:
//
//     let num = 1;
//
// function func() {
//     console.log(num); // функция уже знает, что num = 1
// }
// Вот более сложный пример:
//
//     let num = 1; // функция в этот момент узнает, что num = 1
//
// function func() {
//     console.log(num);
// }
//
// num = 2; // функция в этот момент узнает, что num = 2
// Добавим вызовы функции:
//
//     let num = 1; // функция в этот момент узнает, что num = 1
// func(); // выведет 1
//
// function func() {
//     console.log(num);
// }
//
// func(); // выведет 1
// num = 2; // функция в этот момент узнает, что num = 2
// func(); // выведет 2
// Еще раз: на самом деле функция знает значения внешних переменных, даже не будучи вызванной.


// 258 Лексическое окружение функций / Лексическое окружение функций в JavaScript
//
// Все внешние, доступные функции переменные, называются ее лексическим окружением (англ. LexicalEnvironment).
//
//     В следующем примере функции доступны две переменные: num1 и num2, которые и являются лексическим окружением нашей функции:
//
//     let num1 = 1;
// let num2 = 2;
//
// function func() {
//     // функция знает про переменные num1 и num2
// }
// Само лексическое окружение представляет собой некий внутренний объект JavaScript, привязанный к нашей функции.
// В данном случае его можно представить в следующем виде:
//
// {num1: 1, num2: 2}
// Значение любой переменной лексического окружения всегда равно текущему значению этой переменной:
//
//     let num1 = 1; // окружение {num1: 1}
// let num2 = 2; // окружение {num1: 1, num2: 2}
//
// // Поменяем переменную num1:
// num1 = 123; // окружение {num1: 123, num2: 2}
//
// function func() {
//
// }
// Когда мы пытаемся обратится к какой-либо переменной внутри функции, эта переменная вначале ищется среди
// локальных переменных функции и, если такой переменной там нет, то ищется в лексическом окружении функции.


// 259 Применение лексического окружения / Применение лексического окружения функций в JavaScript
//
// Пусть у нас есть функция, своим результатом возвращающая другую функцию:
//
//     function test() {
//         return function() {
//
//         }
//     }
// Если родительская функция имеет какие-либо переменные, то эти переменные будут содержаться в лексическом окружении
// возвращаемой функции:
//
//     function test() {
//         let num = 1; // переменная родительской функции
//
//         return function() {
//             // лексическое окружение = {num: 1}
//         }
//     }
// Напишем в коде нашей возвращаемой функции алерт, выводящий в консоль значение переменной num:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//         }
//     }
// Давайте теперь вызовем родительскую функцию test и результат ее работы запишем в переменную func:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//         }
//     }
//
// let func = test();
// В переменную func запишется возвращаемая функция. Давайте вызовем нашу функцию - своим результатом она выведет содержимое переменной num:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//         }
//     }
//
// let func = test();
// func(); // выведет 1
// Если же просто попытаться вывести переменную num вне функции - она будет недоступна:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//         }
//     }
//
// console.log(num); // переменная num тут недоступна
// Как вы видите, локальная переменная num привязалась к лексическому окружению нашей функции и теперь,
// вызвав в любом месте кода эту функцию, мы сможем получить значение переменной num,
// даже если в месте вызова сама по себе эта переменная и недоступна.
//
//     На самом деле аналогичного результата можно добиться, сделав переменную num глобальной:
//
//     function test() {
//         return function() {
//             console.log(num);
//         }
//     }
//
// let num = 1; // глобальная переменная
// let func = test();
// func(); // выведет 1
// Здесь, однако, будет существенная разница: в новом варианте переменную num можно менять вне функций (так как она глобальная), а в старом - нет.


// 260 Введение в замыкания / Замыкания в JavaScript
//
// Давайте теперь изучим понятие замыкание (англ. closure). На самом деле вы уже знакомы с этим понятием,
// осталось только узнать правильную терминологию.
//
//     Итак, замыкание - это функция вместе со всеми внешними переменными, которые ей доступны.
//     Или, другими словами, замыкание - это функция вместе со своим лексическим окружением.
//
//     В JavaScript чаще всего, говоря "замыкание функции", имеют ввиду не саму эту функцию, а именно ее внешние переменные.
//     Если же какая-то функция получает переменную из своего лексического окружения, то говорят "переменная берется из замыкания".
//
//     Вспомним код, который мы сделали в предыдущем уроке:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//         }
//     }
//
// let func = test();
// func(); // выведет 1
// В данном случае и можно сказать, что функция func получает значение переменной num из замыкания.
// Также можно сказать, что функция func хранит значение переменной num в замыкании


// 261 Счетчик на замыканиях / Счетчик на замыканиях в JavaScript
//
// Давайте перепишем рассмотренный нами код так, чтобы возвращаемая функция каждый раз увеличивала значение переменной num на единицу:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//             num++; // прибавляем единицу
//         }
//     }
//
// let func = test();
// Получится, что каждый вызов функции func будет выводить в консоль новое значение:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//             num++;
//         }
//     }
//
// let func = test();
//
// func(); //выведет 1
// func(); //выведет 2
// func(); //выведет 3
// func(); //выведет 4
// func(); //выведет 5
// Получается, что мы реализовали счетчик вызова функций, используя замыкание (точнее используя переменную num из замыкания нашей функции).
//
// Учтите, что каждый вызов функции test будет возвращать новую функцию, у которой будет свое замыкание.
// То есть разные счетчики будут работать независимо:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//             num++;
//         };
//     }
//
// let func1 = test(); // первый счетчик
// func1();  //выведет 1
// func1();  //выведет 2
//
// let func2 = test(); // второй счетчик
// func2();  //выведет 1
// func2();  //выведет 2
// Получается, что одна и та же переменная num для разных функций будет иметь разное значение!
//
//     То есть если мы вызовем функцию test два раза, то полученные из нее функции будут работать независимым образом и
//     каждая из этих функций будет иметь свою независимую переменную num.


// 1 Самостоятельно, не подсматривая в мой код, реализуйте счетчик вызова функции, работающий на замыканиях.
//
// function test() {
//     let num = 1;
//
//     return function () {
//         console.log(num);
//         num++;
//     }
// }
//
// let func = test();
// func();
// func();
// func();
//
// let func2 = test();
// func2();
// func2();


// 2 Пусть функция в замыкании хранит число 10.
// Сделайте так, чтобы каждый вызов функции уменьшал это число на 1 и выводил в консоль уменьшенное число.
//
// function test() {
//     let num = 10;
//
//     return function () {
//         console.log(num);
//         num--;
//     }
// }
//
// let func = test();
// func();
// func();
// func();
//
// let func2 = test();
// func2();
// func2();


// 3 Модифицируйте предыдущую задачу так, чтобы отсчет доходил до 0,
// а затем каждый последующий вызов функции выводил в консоль сообщение о том, что отсчет окончен.
//
// function test() {
//     let num = 10;
//
//     return function () {
//         if (num < 0) {
//             console.log('Отсчет окончен');
//         } else {
//             console.log(num);
//             num--;
//         }
//     };
// }
//
// let func = test();
// func();
// func();
// func();
// func();
// func();
// func();
// func();
// func();
// func();
// func();
// func();
// func();
// func();


// 262 Нюанс локальная переменная / Локальная переменная счетчика в JavaScript
//
// Рассмотрим следующий код:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//             num++;
//         };
//     }
//
// test()(); // выведет 1
// test()(); // выведет 1
// Почему всегда будет выводится число 1? Для того, чтобы понять это, перепишем наш код по другому:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//             num++;
//         };
//     };
//
// let func1 = test(); // первая функция
// func1();  //выведет 1
//
// let func2 = test(); // вторая функция
// func2();  //выведет 1
// То есть каждый вызов функции test таким образом: test()(), создает свою функцию со своим замыканием и сразу же вызывает эту функцию.


// 263 Нюанс глобальная переменная / Глобальная переменная счетчика в JavaScript
//
// Вынесем переменную num за функции, тем самым сделав ее глобальной:
//
//     let num = 1; // глобальная переменная
//
// function test() {
//     return function() {
//         console.log(num);
//         num++;
//     };
// }
// В этом случае все возвращаемые функции будут изменять эту глобальную переменную и счетчики будут работать уже зависимо друг от друга:
//
//     let num = 1;
//
// function test() {
//     return function() {
//         console.log(num);
//         num++;
//     };
// }
//
// let func1 = test(); // первый счетчик
// func1();  // выведет 1
// func1();  // выведет 2
//
// let func2 = test(); // второй счетчик
// func2();  // выведет 3
// func2();  // выведет 4
// Почему же наш предыдущий код делал независимые счетчики? Напомню этот код:
//
//     function test() {
//         let num = 1;
//
//         return function() {
//             console.log(num);
//             num++;
//         };
//     };
// Дело в том, что переменная num - локальная внутри функции test. Поэтому каждый вызов test порождает свою локальную переменную.
//
//     Поэтому возвращаемые функции будут ссылаться каждая на свою локальную переменную функции test. Именно так и достигается независимость работы.
//
//     Если же сделать num глобальной переменной - это тоже будет замыканием. Просто лексические окружения возвращаемых
//     функций ссылаются на одну и ту же переменную num - любые изменения с этой переменной будут видны во всех функциях.

